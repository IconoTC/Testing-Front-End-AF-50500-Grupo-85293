# Test unitarios con Vitest

- [Test unitarios con Vitest](#test-unitarios-con-vitest)
  - [Introducción. Usos de Vitest](#introducción-usos-de-vitest)
  - [Instalación y configuración de Vitest en un Mono-repositorio con Typescript y React](#instalación-y-configuración-de-vitest-en-un-mono-repositorio-con-typescript-y-react)
    - [Proyectos con Vite](#proyectos-con-vite)
    - [Mono-repositorio multi-paquete para React con TypeScript](#mono-repositorio-multi-paquete-para-react-con-typescript)
      - [Herramientas de edición de código](#herramientas-de-edición-de-código)
        - [Prettier](#prettier)
        - [.editorconfig para la configuración del editor](#editorconfig-para-la-configuración-del-editor)
    - [Creación de un nuevo proyecto con Vite](#creación-de-un-nuevo-proyecto-con-vite)
      - [Instalación de dependencias](#instalación-de-dependencias)
        - [Configuración de ESLint](#configuración-de-eslint)
      - [Elementos adicionales](#elementos-adicionales)
        - [Herramientas de testing](#herramientas-de-testing)
        - [Mejorar el uso de los matchers extra de @testing-library/jest-dom](#mejorar-el-uso-de-los-matchers-extra-de-testing-libraryjest-dom)
    - [Creación de un proyecto con TS y Vitest](#creación-de-un-proyecto-con-ts-y-vitest)
  - [Estructura de los test unitarios con Jest](#estructura-de-los-test-unitarios-con-jest)
  - [Matchers de Vitest](#matchers-de-vitest)
    - [Igualdad y veracidad](#igualdad-y-veracidad)
    - [Comparación de números](#comparación-de-números)
    - [Comparación de otros tipos de valores](#comparación-de-otros-tipos-de-valores)
    - [Excepciones y errores](#excepciones-y-errores)


## Introducción. Usos de Vitest

En esta unidad nos centraremos en los **test unitarios**, que son como hemos visto, pruebas que se realizan sobre unidades de código, como funciones o clases, de forma aislada. Los test unitarios nos permiten verificar que cada unidad de código funciona correctamente de forma independiente.

De las distintas herramientas de testing ya mencionadas, vamos a utilizar **Vitest**, un framework de testing desarrollado por los responsables de **Vite** que nos permite escribir y ejecutar test unitarios tanto para el **backend** desarrollado con Node como para el **frontend**, basado en VanillaJS, TS o en React.

Como framework de testing, Vitest nos proporciona una serie de utilidades que nos permiten escribir y ejecutar test unitarios de forma sencilla y eficiente, incluyendo herramientas para la creación de **mocks** y **spies**, la realización de pruebas asíncronas basadas en **promesas** y **async/await** o que utilizan **timers**, y la creación y ejecución de pruebas de **snapshot**, etc.

Además de su uso en pruebas unitarias, Vitest puede combinarse con otras herramientas para realizar pruebas de integración, pruebas de componentes, pruebas de aceptación. Especialmete frecuente es su uso junto con [Testing Library](https://testing-library.com/) permite realizar **pruebas de componentes** en aplicaciones web con VanillaJS, TS o con diversos Frameworks, incluyendo **React**.

## Instalación y configuración de Vitest en un Mono-repositorio con Typescript y React

Para instalar React y TypeScript, se puede utilizar **Vite**, un generador de proyectos y empaquetador de código.

### Proyectos con Vite

Según ellos mismos <https://vite.dev/>

> Vite es una herramienta de creación de frontend increíblemente rápida que impulsa la próxima generación de aplicaciones web

- Un **servidor de desarrollo** que ofrece mejoras de funciones enriquecidas con respecto a los módulos ES nativos , por ejemplo, un reemplazo de módulo en caliente (HMR) extremadamente rápido .

- Un **comando de compilación** (**builder**) que agrupa su código con Rollup , pre-configurado para generar activos estáticos altamente optimizados para producción. Vite puede incorporar en esta fase herramientas como PostCSS, Sass, TypeScript, etc.

- La **compatibilidad** con frameworks y la **integración** con otras herramientas se pueden realizar mediante plugins, como sucede en el caso de React

### Mono-repositorio multi-paquete para React con TypeScript

Se crea en la raíz del proyecto:

- un **repositorio Git**
- un **package.json**

- la configuración del mono-repo se incluye en el **package.json**, indicando que los proyectos (paquetes) se encuentran en la carpeta projects

```json
{
  "name": "react-typescript-monorepo",
  "private": true,
  "workspaces": ["projects/*"]
}
```

Se añade también un archivo **.gitignore** para ignorar la carpeta node_modules

```ini gitignore
node_modules
coverage
*.lcov
lib-cov
.env
logs
...
```

Podemos añadir un gitignore mas completo para Node.js desde [gitignore.io](https://www.toptal.com/developers/gitignore) o mediante la extensión de Visual Studio Code "gitignore".

#### Herramientas de edición de código

##### Prettier

- la configuración de Prettier se incluye en el package.json

Algunos de los parámetros más habituales son:

```json
{
  "prettier": {
    "singleQuote": true,
    "semi": false,
    "trailingComma": "all",
    "tabWidth": 2,
    "printWidth": 80
  }
}
```

En nuestro caso, hemos optado por utilizar comillas simples, dejando el resto de parámetros con sus valores por defecto:

```json
"singleQuote": true
```

En algunos casos, es preferible disponer de una copia local de Prettier en lugar de utilizar la que viene instalada con VSC. Para ello, puedes instalar Prettier como una dependencia de desarrollo:

```shell
npm i -D prettier
```

##### .editorconfig para la configuración del editor

Junto a Prettier, es frecuente definir el comportamiento del editor desde el fichero .editorconfig, que es un estándar de configuración de editores de texto. Puedes crear un archivo `.editorconfig` en la raíz de tu proyecto con el siguiente contenido:

```ini
root = true

[*]
charset = utf-8
indent_style = space
indent_size = 4
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = false

[*.html]
indent_size = 2

[*.md]
indent_size = 2

[*.yml]
indent_size = 2

[*.yaml]
indent_size = 2

[*.json]
indent_size = 2
...
```

Podemos generar un archivo `.editorconfig` más completo desde [editorconfig.org](https://editorconfig.org/) o mediante la extensión de Visual Studio Code "EditorConfig for VS Code" que añade una opción al menu contextual de cualquier carpeta.

### Creación de un nuevo proyecto con Vite

Para crear un nuevo proyecto con Vite dentro de la carpeta `projects` del monorepo, se puede utilizar el siguiente comando:

```shell
npm create vite@latest \<nombre-del-proyecto\> -> projects/\<nombre-del-proyecto\>
```

Esto iniciará un asistente que te guiará a través de la creación del proyecto. Puedes elegir entre diferentes plantillas, como React, Vue, Svelte, etc.

Otra opción es indicar directamente el nombre del proyecto y la plantilla que deseas utilizar. Por ejemplo, para crear un proyecto de React con TypeScript, puedes usar el siguiente comando:

```shell
npm create vite@latest \<nombre-del-proyecto\> -- --template react-ts
```

En nuestro caso, seguiremos la creación guiada, indicando:

- Nombre del proyecto: `demo1`
- Framework: `React`
- Variant: `TypeScript + SWC`
- Use rolldown-vite (Experimental)?: `No`
- Install with npm and start now?: `Yes`

[SWC (Speedy Web Compiler)](https://swc.rs/) es un compilador super rápido para JavaScript y TypeScript basado en Rust. Es una alternativa a Babel y es compatible con la mayoría de las características modernas de JavaScript y TypeScript.

El resultado incluye las siguientes dependencias:

```json
 "dependencies": {
    "react": "^19.1.1",
    "react-dom": "^19.1.1"
  },
  "devDependencies": {
   "@eslint/js": "^9.36.0",
    "@types/node": "^24.6.0",
    "@types/react": "^19.1.16",
    "@types/react-dom": "^19.1.9",
    "@vitejs/plugin-react-swc": "^4.1.0",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.22",
    "globals": "^16.4.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.45.0",
    "vite": "^7.1.7"
  }
```

Como se ve, se han instalado TypeScript, React, ESLint y Vite, como builder.
El archivo `tsconfig.json` se crea automáticamente y contiene la configuración básica para TypeScript. Puedes personalizarlo según tus necesidades.
Lo mismo sucede con el archivo de configuración de ESLint, `eslint.config.js`, y con el del propio vite, `vite.config.ts`.

#### Instalación de dependencias

Si no hemos indicado que lo haga al instalador, debemos instalar las dependencias del proyecto manualmente, utilizando el comando `npm i`

Esto instalará todas las dependencias necesarias para el proyecto, incluyendo React, ReactDOM y TypeScript.

Al ser un monorepo, las dependencias se instalan en la raíz del proyecto, en la carpeta `node_modules`.

##### Configuración de ESLint

ESLint puede ubicarse en la raíz del monorepo, ya que su configuración afecta a todos los paquetes.

De acuerdo con el Readme del proyecto generado por Vite, la recomendación respecto a la configuración de ESLint es la siguiente:

```js
export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Remove tseslint.configs.recommended and replace with this
      ...tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      ...tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      ...tseslint.configs.stylisticTypeChecked,
      // Other configs...
    ],
      // other options...
    },
  },
]);
```

En nuestro caso, la configuración incluye los plugins para React Hooks(`eslint-plugin-react-hooks`) y React Refresh(`eslint-plugin-react-refresh`).

La configuración completa que estamos utilizando, incluyendo las parserOptions, extensiones y algunas reglas es la siguiente:

```js
export default tseslint.config([
  globalIgnores(['dist']),
  {
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,,
    },
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      ...tseslint.configs.strict,
      ...tseslint.configs.stylistic,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    rules: {
      ...reactHooks.configs.recommended.rules,
      '@typescript-eslint/consistent-type-definitions': 'off',
      '@typescript-eslint/explicit-function-return-type': 'warn',
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]);
```

Para comprobar el correcto funcionamiento de ESLint, puedes ejecutar el siguiente comando:

```shell
npm run lint
```

#### Elementos adicionales

Además de las dependencias básicas, es posible que desees instalar algunas dependencias adicionales para mejorar tu flujo de trabajo.

##### Herramientas de testing

La más habitual de todas ellas es alguna herramienta de testing, como Vitest, que es un framework de pruebas para Vite. Puedes instalarlo con el siguiente comando:

```shell
npm i -D vitest
npm i -D @vitest/coverage-v8
npm i -D jsdom
npm i -D @testing-library/react @testing-library/jest-dom @testing-library/user-event
```

Se actualiza `tsconfig.app.json` y `tsconfig.node.json` añadiendo `vitest` al array `types`:

```json
{
  "compilerOptions": {
    "types": ["vitest/globals"] // Opcionalmente también "vite/client" si se usa HMR
  }
}
```

Se actualiza `vite.config.ts` del proyecto para añadir la configuración de Vitest:

```ts
/// <reference types="vitest/config" />
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    // opcionalmente
    include: ['**/*.test.ts', '**/*.test.tsx'],
    // opcionalmente, para configurar la cobertura
    coverage: {
      include: ['src/**/*.ts'],
      exclude: ['src/index.ts', 'src/**/types/*.ts'],
    },
  },
});
```

Finalmente puede se interesante agregar un script para ejecutar las pruebas en tu archivo `package.json`:

```json
"scripts": {
  "test": "vitest"
}
```

##### Mejorar el uso de los matchers extra de @testing-library/jest-dom

`testConfig.ts` to src folder:

```ts
import '@testing-library/jest-dom/vitest';
```

Update `vite.config.ts` to add the `setupFiles` property:

```ts
setupFiles: ['src/testConfig.ts'];
```

### Creación de un proyecto con TS y Vitest

De forma manual, podemos crear un proyecto con TypeScript y Vitest sin utilizar Vite, ya que no incluiremos elementos de HTML.

```shell
mkdir demo1-TS
cd demo1-TS
npm init -y
npm install -D typescript
npm install -D vitest
npm install -D @vitest/coverage-v8
```

En este caso, debemos crear el archivo `tsconfig.json` ejecutando

```shell
npx tsc --init:
```

Con un resultado similar a este:

```json
{
  "compilerOptions": {
    "outDir": "./dist",
    "module": "nodenext",
    "target": "esnext",
    "types": ["vitest/globals"],
    "sourceMap": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,

    "noImplicitReturns": true,
    "noImplicitOverride": true,

    "strict": true,
    "jsx": "react-jsx",
    "verbatimModuleSyntax": true,
    "isolatedModules": true,
    "noUncheckedSideEffectImports": true,
    "moduleDetection": "force",
     "skipLibCheck": true
  },
  "include": ["src"],
  "exclude": ["vite.config.ts"]
}
```

En el archivo `package.json`, añadimos el script para ejecutar Vitest:

```json
"scripts": {
  "build": "tsc",
  "dev": "tsc -w",
  "test": "vitest",
  "test:c": "vitest run --coverage",
  "lint": "eslint . --ext .ts"
}
```

Añadimos también el archivo de configuración de Vitest, `vite.config.ts`:

```ts
/// <reference types="vitest/config" />
import { defineConfig } from 'vite';
export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    // opcionalmente
    include: ['**/*.test.ts', '**/*.test.tsx'],
    // opcionalmente, para configurar la cobertura
    coverage: {
      include: ['src/**/*.ts'],
      exclude: ['src/index.ts', 'src/**/types/*.ts'],
    },
  },
});
```

## Estructura de los test unitarios con Jest

La estructura de los ficheros de test creados con Jest se corresponde con la que describíamos en la unidad anterior al referirnos a los test unitarios.
Cada fichero de test se encarga de verificar el correcto funcionamiento de una unidad de código, como una función o una clase, de forma aislada.

- Los test unitarios se agrupan en **test suites** que se definen con la función `describe`.
- Cada test unitario se corresponde con una función que se define con la palabra `it` o `test`, que representa un caso de prueba concreto de una función o un método de una clase
- Las aserciones se realizan con la función `expect` de Jest, que se encarga de comparar el valor esperado con el valor obtenido.
- La forma en que se lleva a cabo dicha comparación depende del matcher empleado: una función booleana que se encarga de comparar el valor esperado con el valor obtenido. Una de las funciones más comunes para realizar aserciones es la función `toBe`.

Veamos el ejemplo con las funciones `add` y `product`:

```ts
// calc.ts
export function add(a: number, b: number): number {
  return a + b;
}

export function product(a: number, b: number): number {
  return a * b;
}
```

```ts
// calc.test.ts
import { product } from "./calc";
describe('The function product', () => {
  it("should return the product of two numbers", () => {
    expect(product(1, 2)).toBe(2);
  });
});
```

Un mejor enunciado de los test puede ayudar a entender mejor qué es lo que se está probando.

```ts
import { add } from './01-calc.js';
describe('testing add', () => {
    it('add 1 + 2 should be 3', () => {
        expect(add(1, 2)).toBe(3);
    });
    it('add -1 + -1 should be -2', () => {
        expect(add(-1, -1)).toBe(-2);
    });
 }); // test suite   
```

Como hemos visto, la organización del código puede seguir distintos patrones, como el **patrón AAA** (Arrange, Act, Assert) o el **patrón Given-When-Then**.

El ejemplo anterior utilizando el patrón AAA sería:

```js
// product.test.js
import { product } from "./product";

describe('Using function product with 1 and 2', () => {
  it("should return 2", () => {
    // Arrange
    const a = 1;
    const b = 2;
    const expected = 2
    // Act
    const result = product(a, b);
    // Assert
    expect(result).toBe(expected);
  });
});
```

El mismo ejemplo utilizando el patrón Given-When-Then y diversos niveles de describe sería:

```js
// product.test.js
import { product } from "./product";
describe("Given product function", () => {
  describe("when we multiply two numbers, 2 and 3", () => {
    const a = 2;
    const b = 3;
    it("should return 6", () => {
      const expected = 6;
      const result = product(a, b);
      expect(result).toBe(expected);
    });
  });
});
```

En este caso, el patron Given-When-Then añade un nivel de abstracción a los test, que se corresponden con las distintas partes de la función que se está testando. Como cualquier abstracción, puede suponer mayor cantidad de código, pero también mayor claridad en la estructura de los test que se refleja cuando vemos la salida de los test en la terminal.

```sh
  Given product function
    when we multiply two numbers, 2 and 3
      √ should return 6
```

El uso de estos patrones puede cobrar mayor sentido en función de la complejidad del conjunto de test que se estén realizando, y de la cantidad de test que se estén realizando.

## Matchers de Vitest

Vitest proporciona una serie de funciones que nos permiten realizar aserciones en los test unitarios. Estas funciones se conocen como **matchers** y se utilizan para comparar el valor esperado con el valor obtenido en el test.

### Igualdad y veracidad

En este apartado se incluyen algunos de los matchers más comunes:

- `toBe`: Compara si dos valores son iguales utilizando el operador `===`. Solo debe usarse para comparar valores primitivos.
- `toEqual`: Compara si dos valores son iguales utilizando el algoritmo de comparación de objetos de JavaScript. Se utiliza para comparar objetos y arrays.
- `toBeNull`: Comprueba si un valor es `null`.
- `toBeUndefined`: Comprueba si un valor es `undefined`.
- `toBeDefined`: Comprueba si un valor está definido.
- `toBeTruthy`: Comprueba si un valor es verdadero, es decir, hace casting a true.
- `toBeFalsy`: Comprueba si un valor es falso, es decir hace casting a false.

Ejemplo de uso de matchers de igualdad y veracidad

```ts
describe("Matchers de igualdad y veracidad", () => {
  it("toBe", () => {
    expect(1 + 2).toBe(3);
  });
  it("toEqual", () => {
    expect({ a: 1 }).toEqual({ a: 1 });
  });
  it("toBeNull", () => {
    expect(null).toBeNull();
  });
  it("toBeUndefined", () => {
    expect(undefined).toBeUndefined();
  });
  it("toBeDefined", () => {
    expect(1).toBeDefined();
  });
  it("toBeTruthy", () => {
    expect(true).toBeTruthy();
  });
  it("toBeFalsy", () => {
    expect(false).toBeFalsy();
  });
});
```

### Comparación de números

Entre los matchers específicos para valores de tipo number encontramos:

- `toBeGreaterThan`: Comprueba si un valor es mayor que otro.
- `toBeGreaterThanOrEqual`: Comprueba si un valor es mayor o igual que otro.
- `toBeLessThan`: Comprueba si un valor es menor que otro.
- `toBeLessThanOrEqual`: Comprueba si un valor es menor o igual que otro.
- `toBeCloseTo`: Comprueba si un valor es cercano a otro, con un margen de error.

Ejemplo de uso de matchers de comparación de números

```js
describe("Matchers de comparación de números", () => {
  it("toBeGreaterThan", () => {
    expect(3).toBeGreaterThan(2);
  });
  it("toBeGreaterThanOrEqual", () => {
    expect(3).toBeGreaterThanOrEqual(3);
  });
  it("toBeLessThan", () => {
    expect(2).toBeLessThan(3);
  });
  it("toBeLessThanOrEqual", () => {
    expect(2).toBeLessThanOrEqual(2);
  });
  it("toBeCloseTo", () => {
    expect(0.1 + 0.2).toBeCloseTo(0.3);
  });
});
```

### Comparación de otros tipos de valores

Otros matchers disponibles par otros tipos de valores son:

- `toBeInstanceOf`: Comprueba si un valor es una instancia de una clase.
- `toMatch`: Comprueba si un valor coincide con una expresión regular.
- `toContain`: Comprueba si un valor contiene otro valor. Puede utilizarse con arrays y strings.
- `toHaveLength`: Comprueba si un valor tiene una longitud determinada. Puede utilizarse con arrays y strings.

Ejemplo de uso de matchers de comparación de otros tipos de valores

```js
describe("Matchers de comparación de otros tipos de valores", () => {
  it("toBeInstanceOf", () => {
    expect(new Date()).toBeInstanceOf(Date);
  });
  it("toMatch", () => {
    expect("abc").toMatch(/a/);
  });
  it("toContain", () => {
    expect([1, 2, 3]).toContain(2);
  });
  it("toHaveLength", () => {
    expect("abc").toHaveLength(3);
  });
});
```

### Excepciones y errores

El matchers para errores es

- `toThrow`: Comprueba si una función lanza una excepción.

Su variante `toThrowError` comprobaba si una función lanza una excepción con un mensaje determinado, pero ha sido deprecado en Jest 24.9.0.

En caso de los test de snapshot, Jest proporciona los siguientes matchers para errores:

- `toThrowErrorMatchingSnapshot`: Comprueba si una función lanza una excepción que coincide con un snapshot.
- `toThrowErrorMatchingInlineSnapshot`: Comprueba si una función lanza una excepción que coincide con un snapshot en línea.

Algunos ejemplos de uso de matchers para errores:

```js
const throwError = () => {
  throw new Error("Error");
};

function makePossibleError(n) {
  if (n > 1) {
    throw new Error("Error");
  }
}
describe("Matchers de errores", () => {
  it("toThrow", () => {
    expect(throwError).toThrow();
  });
  it("toThrow", () => {
    expect(() => makePossibleError(2)).toThrow();
  });
});
```

En los test de casos en las que una función lanzan un error, esta se pasa como **callback** al expect, para que Jest pueda capturar la excepción y comprobar si se ha lanzado. En el caso de la función `makePossibleError`, que necesita un argumento, se pasa como callback una función anónima que llama a `makePossibleError` con el argumento 2.
