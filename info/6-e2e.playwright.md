# E2E Tests en el frontend

- [E2E Tests en el frontend](#e2e-tests-en-el-frontend)
  - [Tests E2E con Playwright](#tests-e2e-con-playwright)
    - [Instalaci칩n de Playwright](#instalaci칩n-de-playwright)
      - [Ejecuci칩n y prueba de la instalaci칩n](#ejecuci칩n-y-prueba-de-la-instalaci칩n)
      - [Report de pruebas](#report-de-pruebas)
      - [Configuraciones adicionales](#configuraciones-adicionales)
    - [Uso de Playwright: creaci칩n de tests](#uso-de-playwright-creaci칩n-de-tests)
      - [Localizadores](#localizadores)
        - [Localizadores modernos](#localizadores-modernos)
        - [Roles de accesibilidad](#roles-de-accesibilidad)
        - [Localizadores legacy](#localizadores-legacy)
      - [Aserciones (assertions)](#aserciones-assertions)
      - [游쮼jemplo: test de Home Page de Practice Software Testing](#ejemplo-test-de-home-page-de-practice-software-testing)
      - [Credenciales del usuario (auth credentials)](#credenciales-del-usuario-auth-credentials)
    - [Tests de un API](#tests-de-un-api)
      - [游쮼jemplo: test de la API de Practice Software Testing](#ejemplo-test-de-la-api-de-practice-software-testing)
    - [Herramienta Codegen para la generaci칩n autom치tica de tests](#herramienta-codegen-para-la-generaci칩n-autom치tica-de-tests)
    - [Tests de accesibilidad](#tests-de-accesibilidad)
    - [Tests de navegaci칩n basada en teclado](#tests-de-navegaci칩n-basada-en-teclado)
      - [Matchers y aserciones de accesibilidad](#matchers-y-aserciones-de-accesibilidad)
      - [Tests de accesibilidad con axe-core](#tests-de-accesibilidad-con-axe-core)

Los test de extremo a extremo (E2E) son una parte fundamental de la estrategia de pruebas de cualquier aplicaci칩n, ya que permiten validar el comportamiento de la aplicaci칩n en su conjunto, desde la perspectiva del usuario final. En el caso de las aplicaciones web, los test E2E se utilizan para simular la interacci칩n del usuario con la interfaz gr치fica, comprobando que las acciones del usuario producen los resultados esperados.

Para ello se utilizan diversas herramientas que permiten automatizar la interacci칩n con la aplicaci칩n, simulando el comportamiento del usuario y validando los resultados obtenidos. Entre las herramientas m치s populares para realizar test E2E en aplicaciones web se encuentran [Cypress](https://www.cypress.io/), la combinaci칩n de [Puppeteer](https://pptr.dev/) Jest y m치s recientemente, [Playwright](https://playwright.dev/). En nuestro caso veremos c칩mo realizar test E2E en una aplicaci칩n web utilizando la herramienta Playwright.

## Tests E2E con Playwright

Playwright es una herramienta de automatizaci칩n de pruebas de c칩digo abierto desarrollada por **Microsoft** que permite realizar pruebas E2E en aplicaciones web. Playwright es compatible con m칰ltiples navegadores (Chromium, Firefox y WebKit) y ofrece una API sencilla y potente para interactuar con la aplicaci칩n web.

[Evoluci칩n de herramientas e2e en npm](https://npmtrends.com/cypress-vs-playwright-vs-puppeteer-vs-selenium-webdriver-vs-webdriverio)

### Instalaci칩n de Playwright

Para instalar Playwright en nuestro proyecto o crear uno nuevo, podemos utilizar npm o yarn. A continuaci칩n se muestra c칩mo instalar Playwright utilizando npm:

```shell
npm init playwright@latest <nombre-del-proyecto>
```

Si no se indica la carpeta del proyecto, se utilizar치 la carpeta actual.

Cuando se le solicite, seleccionamos/confirmamos:

- TypeScript o JavaScript (predeterminado: TypeScript) - No se pregunta si el proyecto ya tiene un package.json
- Nombre de la carpeta de pruebas (predeterminado: tests, o e2e si tests ya existe)
- Agregar un flujo de trabajo de GitHub Actions (recomendado para CI)
- Instalar navegadores Playwright (predeterminado: s칤) - Instala Chromium, Firefox y WebKit

El resultado de la instalaci칩n es es siguiente estructura de carpetas:

```shell
playwright.config.ts         # Test configuration
package.json
package-lock.json            # Or yarn.lock / pnpm-lock.yaml
tests/
  example.spec.ts            # Minimal example test
```

#### Ejecuci칩n y prueba de la instalaci칩n

Para ejecutar las pruebas de ejemplo y verificar que Playwright se ha instalado correctamente, podemos utilizar el siguiente comando:

```shell
npx playwright test
```

Algunas modificaciones de este comando que podemos probar ahora son:

- Ver la ventana del navegador: agregar `--headed`.
- Ejecutar un solo proyecto/navegador: `--project=chromium`.
- Ejecute un archivo: `npx playwright test example`.
- Ejecutar en modo debug: `--debug`.
- Autogenerar los tests: `npx playwright codegen`.
- Interfaz de usuario interactivo: `--ui`.

Esta 칰ltima opci칩n abre una **interfaz gr치fica** que permite ejecutar y depurar las pruebas de manera interactiva. Es probablemente la forma m치s c칩moda de trabajar con Playwright durante el desarrollo de las pruebas.

En esta interfaz veremos los test, pero no se ejecutar치n hasta que se lo indiquemos (bot칩n play). Al ejecutar un test, veremos el resultado en la interfaz, incluyendo los resultados en el panel correspondiente al navegador para cada una de las etapas de la prueba.

Lo habitual sera a침adir scripts en el package.json para facilitar la ejecuci칩n de los tests:

```json
"scripts": {
  "e2e:dev": "playwright test --project=chromium --ui",
  "e2e:headed": "playwright test --headed",
  "e2e": "playwright test"
}
```

#### Report de pruebas

Playwright genera reportes de las pruebas ejecutadas, incluyendo capturas de pantalla, videos y trazas de las pruebas. Estos reportes son 칰tiles para analizar los resultados de las pruebas y depurar posibles errores. Para ver el reporte HTML de las pruebas, podemos utilizar el siguiente comando:

```shell
npx playwright show-report
```

#### Configuraciones adicionales

En el archivo `playwright.config.ts` podemos configurar diversas opciones para las pruebas, como el tiempo de espera, la configuraci칩n del navegador, la configuraci칩n de la red, entre otras. A continuaci칩n se muestra un ejemplo de configuraci칩n b치sica:

```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  timeout: 30_000,
  globalTimeout: 600_000,
  expect: {
    timeout: 5_000,
  },
  use: {
    /* Base URL to use in actions like `await page.goto('')`. */
    // baseURL: 'http://localhost:3000',

    /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
    trace: 'on',
    actionTimeout: 0,
    ignoreHTTPSErrors: true,
    video: 'retain-on-failure',
    screenshot: 'only-on-failure',
  },
  projects: [
    {
      name: 'desktop-chrome',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'desktop-firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'desktop-safari',
      use: { ...devices['Desktop Safari'] },
    },
  ],
});
```

Si el proyecto corresponde a una url, se la indicaremos en la propiedad `baseURL`.

Podr칤a ser una url local, como `http://localhost:4200` o una url remota, como `https://mi-aplicacion.com`.

Algunas p치ginas disponibles para poder llevar a cabo pruebas son:

- [Practice Software Testing](https://practicesoftwaretesting.com/) by Roy de Kleijn (Testsmith)
- [OpenCart](https://opencart.abstracta.us/)
- [Sauce Demo](https://www.saucedemo.com/)

Para la primera de ellas, la configuraci칩n de `use` ser칤a la siguiente:

```typescript
// playwright.config.ts
  use: {
    baseURL: "https://practicesoftwaretesting.com",
    testIdAttribute: "data-test",
  }
```

Para definir un setup para todas las pruebas, podemos crear un archivo y definirlo como un proyecto (luego veremos su uso), creando luego una dependencia en los proyectos que lo necesiten:

```typescript
// playwright.config.ts
  projects: [
    {
      name: 'setup',
      testDir: './',
      testMatch: /.*\.setup\.ts/,
    },
    {
      name: "chromium",
      dependencies: ["setup"],
      use: { ...devices["Desktop Chrome"], permissions: ["clipboard-read"] },
    },
  ],
```

Trabajando en local (Angular, React..) se suele activar la 칰ltima opci칩n del apartado de `webServer` para iniciar el servidor de desarrollo antes de ejecutar las pruebas:

```typescript
// playwright.config.ts
  webServer: {
    command: 'npm start',
    port: 4200,
    reuseExistingServer: !process.env.CI,
  },
```

### Uso de Playwright: creaci칩n de tests

Para crear tests con Playwright, podemos utilizar la API proporcionada por la herramienta para interactuar con la aplicaci칩n web y validar los resultados obtenidos. A continuaci칩n se muestra un ejemplo b치sico de un test E2E utilizando Playwright:

```typescript
import { test, expect } from '@playwright/test';

test.describe('Pruebas b치sicas con Playwright', () => {
  test('test b치sico', async ({ page }) => {
    await page.goto('https://practicesoftwaretesting.com');
    expect(await page.title()).toBe('Practice Software Testing');
  });
});
```

Playwright proporciona dos objetos principales para crear los tests: `test` y `expect`.

El objeto `test` se utiliza

- definir una suite de pruebas con `test.describe()`,
- definir cada test con `test()`

Dentro de la funci칩n del test,

- recibe como par치metro el objeto `page` que se utiliza para interactuar con la p치gina web, como navegar a una URL con `page.goto()`.
- el objeto `expect` se utiliza para validar los resultados obtenidos, como verificar el t칤tulo de la p치gina con `expect(page.title).toBe()`. Siempre es as칤ncrono, por lo que hay que usar `await` para obtener el valor.

#### Localizadores

Playwright utiliza localizadores para identificar y seleccionar elementos en la p치gina web. Los localizadores son una forma de describir c칩mo encontrar un elemento en el DOM (Document Object Model) de la p치gina. Playwright proporciona localizadores legacy, como selectores CSS 0 XPath, junto con localizadores modernos, muy similares a los existentes en bibliotecas como Testing Library.

##### Localizadores modernos

Los localizadores modernos son m치s robustos y f치ciles de usar, ya que se basan en atributos accesibles y roles de ARIA. Algunos ejemplos de localizadores modernos son:

- `getByRole`
- `getByText`
- `getByLabel`
- `getByPlaceholder`
- `getByAltText`
- `getByTitle`
- `getByTestId`

Estos localizadores permiten definir dos estrategias de selecci칩n diferentes:

- En funci칩n de la accesibilidad de los elementos (roles, labels, etc.)
- En funci칩n de ids espec칤ficos para testing (data-test-id u otro atributo personalizado, que se puede definir en la configuraci칩n)

##### Roles de accesibilidad

Son uno de los elementos clave de los localizadores modernos. Los roles de accesibilidad son atributos que describen la funci칩n de un elemento en la interfaz de usuario, como un bot칩n, un enlace o un cuadro de texto. Playwright utiliza estos roles para identificar y seleccionar elementos en la p치gina web.

Estos roles pueden ser

- intr칤nsecos (definidos por el propio HTML); por ejemplo, un `<button>` tiene el rol de **"button"** de forma predeterminada, o un `<a>` con atributo `href` tiene el rol de **"link"**. Los roles de cada elemento HTML se pueden consultar en la [especificaci칩n de roles de WAI-ARIA](https://www.w3.org/TR/wai-aria-1.2/#role_definitions) o en la p치gina del elemento en [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element).

- expl칤citos (definidos mediante atributos ARIA), como `role="button"` o `role="navigation"`.

Adem치s cada elemento con un rolo puede tener atributos de accesibilidad adicionales que proporcionan m치s informaci칩n sobre el elemento, como `name`, `pressed`, `expanded`, etc. El `name` es especialmente importante, ya que se utiliza para identificar el elemento en los localizadores modernos. Depende de cada rol, pero generalmente se deriva del texto visible del elemento o de atributos como `aria-label` o `aria-labelledby`.

Por ejemplo, para seleccionar un bot칩n con el texto "Enviar", podemos utilizar el siguiente localizador:

```typescript
const sendButton = page.getByRole('button', { name: 'Enviar' });
```

##### Localizadores legacy

Adem치s de los localizadores modernos, Playwright tambi칠n admite localizadores legacy basados en selectores CSS y XPath. Estos localizadores son 칰tiles cuando no se pueden utilizar los localizadores modernos, pero se recomienda utilizar los modernos siempre que sea posible.

- **selectores CSS**: sigue la sintaxis est치ndar de CSS para seleccionar elementos en la p치gina web por id, por clase, por atributo o mediante selectores combinados, que utilizan diversos operadores adem치s de pseudo-clases y pseudo-elementos. Por ejemplo, para seleccionar un elemento con la clase "mi-clase", podemos utilizar el siguiente localizador:

```typescript
const miElemento = page.locator('.mi-clase');
```

- **expresiones XPath**: utiliza la sintaxis est치ndar de XPath para seleccionar elementos en la p치gina web mediante rutas y expresiones XPath. Por ejemplo, para seleccionar un elemento `<div>` con un atributo `data-test-id` igual a "mi-elemento", podemos utilizar el siguiente localizador:

```typescript
const miElemento = page.locator('//div[@data-test-id="mi-elemento"]');
```

Una manera de probar XPath es utilizando la funci칩n `$x()` en la consola de herramientas de desarrollo del navegador.Esta funci칩n te permite evaluar una expresi칩n XPath y devuelve un array de los elementos del DOM que coinciden con la expresi칩n.

En XPath, `//` se utiliza para seleccionar elementos en cualquier lugar del documento. Por tanto, al ejecutar $x("//") la consola devuelve un array con todos los elementos del DOM de la p치gina web actual.

Es una forma r치pida y 칰til de seleccionar elementos usando expresiones XPath. Por ejemplo, si escribes $x("//p") en la consola, obtendr치s un array con todos los elementos \<p> (p치rrafo) de la p치gina.

#### Aserciones (assertions)

Playwright proporciona una serie de aserciones (assertions) que permiten validar los resultados obtenidos en las pruebas. Estas aserciones se utilizan junto con el objeto `expect` para verificar que los elementos de la p치gina web cumplen con ciertas condiciones. Se pueden dividir en dos categor칤as:

- Aserciones de estado (locator assertions): permiten verificar el estado de un elemento en la p치gina web, como si est치 visible, habilitado, seleccionado, entre otros. Algunos ejemplos de aserciones de estado son:

  - `toBeVisible()`
  - `toBeHidden()`
  - `toBeEnabled()`
  - `toBeDisabled()`
  - `toBeChecked()`
  - `toBeUnchecked()`

Cuando estas aserciones fallan, se reintentan autom치ticamente durante un per칤odo de tiempo configurado (por defecto 5 segundos), lo que ayuda a manejar situaciones en las que el estado del elemento puede cambiar din치micamente.

Algunos ejemplos de uso de aserciones de estado son:

```typescript
await page.goto('https://practicesoftwaretesting.com/formulario');
await expect(page).toHaveURL(/.*formulario/);
const button = page.getByRole('button', { name: 'Enviar' });
await expect(button).toBeVisible();
await expect(button).toBeEnabled();
```

- Aserciones de valor (value assertions): permiten verificar el valor de un elemento en la p치gina web, como el texto, el atributo, el valor del campo, entre otros. Algunos ejemplos de aserciones de valor son:

  - `toHaveText()`
  - `toHaveAttribute()`
  - `toHaveValue()`
  - `toHaveClass()`
  - `toHaveCount()`

Estas aserciones no se reintentan autom치ticamente, sino que se eval칰an una 칰nica vez. Si el valor del elemento puede cambiar din치micamente, es recomendable utilizar las aserciones de estado para esperar a que el elemento est칠 en el estado esperado antes de verificar su valor.

Algunos ejemplos de uso de aserciones de valor son:

```typescript
const message = page.getByTestId('message');
await expect(message).toHaveText('Operaci칩n exitosa');
await expect(message).toHaveClass(/success/);
```

#### 游쮼jemplo: test de Home Page de Practice Software Testing

Veamos un ejemplo completo de un test E2E utilizando Playwright para validar la p치gina de inicio de [Practice Software Testing](https://practicesoftwaretesting.com/). En este ejemplo, se realizan varias validaciones en la p치gina

- verificar el t칤tulo
- la presencia de elementos (login)
- funcionalidad de b칰squeda: buscar un producto y validar que aparecen resultados

```typescript
import { test, expect } from '@playwright/test';

test.describe('Home page with no auth', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('https://practicesoftwaretesting.com/');
  });

  test('check sign in', async ({ page }) => {
    await expect(page.getByTestId('nav-sign-in')).toHaveText('Sign in');
  });

  test('validate page title', async ({ page }) => {
    await expect(page).toHaveTitle(
      'Practice Software Testing - Toolshop - v5.0'
    );
  });

  test('grid loads with 9 items', async ({ page }) => {
    const productGrid = page.locator('.col-md-9');
    await expect(productGrid.getByRole('link')).toHaveCount(9);
    expect(await productGrid.getByRole('link').count()).toBe(9);
  });

  test('search for Thor Hammer', async ({ page }) => {
    const productGrid = page.locator('.col-md-9');
    await page.getByTestId('search-query').fill('Thor Hammer');
    await page.getByTestId('search-submit').click();
    await expect(productGrid.getByRole('link')).toHaveCount(1);
    await expect(page.getByAltText('Thor Hammer')).toBeVisible();
  });
});
```

#### Credenciales del usuario (auth credentials)

Una operaci칩n que podr칤amos testar es la posibilidad de iniciar sesi칩n en la aplicaci칩n web. Para ello, necesitar칤amos disponer de unas credenciales v치lidas (usuario y contrase침a) para poder realizar el test de autenticaci칩n. En el repositorio de [Practice Software Testing](https://github.com/testsmith-io/practice-software-testing) se proporcionan unas credenciales de prueba que podemos utilizar.

Utilizaremos las siguientes credenciales:

- mail: `customer@practicesoftwaretesting.com`
- Contrase침a: `welcome01`
- Usuario: `Jane Doe`
- Role: `user`

En lugar de un test normal, crearemos un `setup` que nos permita reutilizar el c칩digo de autenticaci칩n en varios tests.
Crearemos un archivo `auth.setup.ts` con el siguiente contenido:

```typescript
import { test as setup, expect } from '@playwright/test';

setup('Create customer 01 auth', async ({ page, context }) => {
  const email = 'customer@practicesoftwaretesting.com';
  const password = 'welcome01';
  const customer01AuthFile = '.auth/customer01.json';

  await page.goto('https://practicesoftwaretesting.com/auth/login');

  await page.getByTestId('email').fill(email);
  await page.getByTestId('password').fill(password);
  await page.getByTestId('login-submit').click();

  await expect(page.getByTestId('nav-menu')).toContainText('Jane Doe');
  await context.storageState({ path: customer01AuthFile });
});
```

Para que esto funcione es imprescindible haberlo definido en la configuraci칩n de Playwright como un proyecto de setup, tal y como vimos anteriormente.

En el fichero `.auth/customer01.json` estaremos guardando el estado de autenticaci칩n del usuario, incluyendo cookies y almacenamiento local (localStorage), una vez que se ha iniciado sesi칩n correctamente. La primera vez que ejecutemos este setup, se realizar치 el proceso de login y se guardar치n las credenciales en el archivo indicado. (Puede que el resto de los test fallen esta vez). El archivo de estado de autenticaci칩n, debe estar en el `.gitignore` para evitar subirlo al repositorio.

Una vez creado el archivo de estado de autenticaci칩n, ya no ser치 necesario volver a iniciar sesi칩n en cada test, ya que Playwright podr치 reutilizar las credenciales de autenticaci칩n en otros tests mediante el comando `test.use({ storageState: '.auth/customer01.json' })`. As칤 lo hacemos en el siguiente test:

```typescript
test.describe('Home page customer 01 auth', () => {
  test.use({ storageState: '.auth/customer01.json' });
  test.beforeEach(async ({ page }) => {
    await page.goto('https://practicesoftwaretesting.com/');
  });

  test('check customer 01 is signed in', async ({ page }) => {
    await expect(page.getByTestId('nav-sign-in')).not.toBeVisible();
    await expect(page.getByTestId('nav-menu')).toContainText('Jane Doe');
  });
});
```

### Tests de un API

Playwright tambi칠n permite realizar pruebas de APIs mediante su m칩dulo `APIRequestContext`. Este m칩dulo proporciona una forma sencilla de enviar solicitudes HTTP y validar las respuestas obtenidas. A continuaci칩n se muestra un ejemplo b치sico de un test de API utilizando Playwright:

```typescript
import { test, expect } from '@playwright/test';

test('GET /api/customers', async ({ request }) => {
  const response = await request.get('/api/customers');
  expect(response.status()).toBe(200);
  expect(await response.json()).toEqual(
    expect.arrayContaining([expect.objectContaining({ id: 1 })])
  );
});
```

En este caso, el callback del test recibe como par치metro el objeto `request` que se utiliza para enviar solicitudes HTTP, como una solicitud GET a la URL `/api/customers` con `request.get()`.

Las request a la API devuelven un objeto definido por el interface `APIResponse`, que contiene informaci칩n sobre la respuesta obtenida, como el c칩digo de estado, los encabezados y el cuerpo de la respuesta. En cierto modo similar a la interfaz `Response` de la API Fetch.

Luego, se utiliza el objeto `expect` para validar la respuesta obtenida:

- verificar el c칩digo de estado con `expect(response.status()).toBe(200)`
- comprobar el contenido de la respuesta, convirtiendo el stream (buffer) de datos a JSON con `expect(response.json()).toEqual()`.

#### 游쮼jemplo: test de la API de Practice Software Testing

Veamos un ejemplo completo de un test E2E utilizando Playwright para validar la API de [Practice Software Testing](https://api.practicesoftwaretesting.com). En este ejemplo, se realizan varias validaciones en la API, con los m칠todos GET y POST.

```typescript
import { test, expect } from '@playwright/test';

test('GET /products', async ({ request }) => {
  const apiUrl = 'https://api.practicesoftwaretesting.com';
  const response = await request.get(apiUrl + '/products');

  expect(response.status()).toBe(200);
  const body = await response.json();
  expect(body.data.length).toBe(9);
  expect(body.total).toBe(53);
});

test('POST /users/login', async ({ request }) => {
  const apiUrl = 'https://api.practicesoftwaretesting.com';
  const response = await request.post(apiUrl + '/users/login', {
    data: {
      email: 'customer@practicesoftwaretesting.com',
      password: 'welcome01',
    },
  });

  expect(response.status()).toBe(200);
  const body = await response.json();
  expect(body.access_token).toBeTruthy();
});
```

Para probar un el m칠todo POST usamos el login, proporcion치ndole en el cuerpo de la solicitud (data) las credenciales del usuario.

### Herramienta Codegen para la generaci칩n autom치tica de tests

Playwright incluye una herramienta llamada `codegen` que permite generar autom치ticamente c칩digo de pruebas E2E a partir de la interacci칩n del usuario con la aplicaci칩n web. Esta herramienta es 칰til para crear pruebas r치pidamente y aprender c칩mo utilizar la API de Playwright.

Esta herramienta se ejecuta con el siguiente comando:

```shell
npx playwright codegen <url>
```

Con este comando, se abre una ventana del navegador que carga la URL especificada, junto con una segunda ventana que muestra el c칩digo generado autom치ticamente. A medida que interact칰as con la aplicaci칩n web en la primera ventana, el c칩digo de prueba correspondiente se genera en tiempo real en la segunda ventana.

Esta herramienta es especialmente 칰til para crear pruebas r치pidamente, ya que puedes realizar acciones en la interfaz de usuario y ver c칩mo se traduce eso en c칩digo de prueba. Adem치s, puedes modificar el c칩digo generado seg칰n tus necesidades y guardarlo para su uso posterior.

### Tests de accesibilidad

Playwright tambi칠n ofrece soporte para realizar pruebas de accesibilidad en aplicaciones web. La accesibilidad es un aspecto crucial del desarrollo web, ya que garantiza que las aplicaciones sean utilizables por todas las personas, incluyendo todas aquellas que puntual o permanentemente puedan tener necesidades especiales.

- A nivel de **localizadores**, como ya hemos visto Playwright facilita la selecci칩n de elementos bas치ndose en roles y atributos de accesibilidad, lo que fomenta buenas pr치cticas de desarrollo accesible.

- testando **navegaci칩n basada en el teclado**, manejo de focos, y otros aspectos relacionados con la accesibilidad.

- utilizando matchers y aserciones espec칤ficas para validar propiedades de accesibilidad de los elementos en la p치gina.

- Para realizar pruebas de accesibilidad con Playwright, podemos utilizar la integraci칩n con la biblioteca [axe-core](https://github.com/dequelabs/axe-core).

### Tests de navegaci칩n basada en teclado

A partir de la versi칩n 1.30, Playwright incluye soporte nativo para probar la navegaci칩n basada en teclado, lo que facilita la validaci칩n de la accesibilidad de las aplicaciones web.

Si tenemos un campo de b칰squeda seguido por los botones de cancelar y buscar, podemos probar la navegaci칩n mediante la tecla Tab de la siguiente manera:

```typescript
import { test, expect } from '@playwright/test';

test('Keyboard navigation test', async ({ page }) => {
  await page.goto('https://practicesoftwaretesting.com/');

  // Foco inicial en el campo de b칰squeda
  await page.getByRole('textbox', { name: 'search-query' }).focus();
  'Sample'.split('').forEach(async (char) => {
    await page.keyboard.press(char);
  });
  await page.keyboard.press('Tabulator');
  await page.keyboard.press('Tabulator');
  await expect(
    page.getByRole('button', { name: 'search-submit' })
  ).toBeFocused();
  page.keyboard.press('Enter');
  await expect(page.getByAltText('Sample Product')).toBeVisible();
});
```

#### Matchers y aserciones de accesibilidad

Playwright proporciona matchers y aserciones espec칤ficas para validar propiedades de accesibilidad de los elementos en la p치gina. Estos matchers permiten verificar aspectos como el rol, el nombre accesible, el estado y las propiedades ARIA de los elementos. Algunos ejemplos de matchers y aserciones de accesibilidad son:

- `toHaveRole()`
- `toHaveAccessibleName()`
- `toHaveAccessibleDescription()`
- `toBeDisabled()`
- `toBeEnabled()`
- `toBeChecked()`
- `toBeVisible()`

As칤, aunque usemos localizadores basados en test-id u otros selectores, podemos validar que los elementos cumplen con los requisitos de accesibilidad:

```typescript
const submitButton = page.locator('#submit-button');
await expect(submitButton).toHaveRole('button');
await expect(submitButton).toHaveAccessibleName('Submit Form');
```

En este contesto puede ser interesante generar el **치rbol de accesibilidad** de la p치gina o de parte de ella para analizarlo. Ser칤a el equivalente al DOM pero en t칠rminos de accesibilidad y se puede obtener al usar la pesta침a de accesibilidad en los elementos de las herramientas de desarrollo del navegador para habilitarlo y luego hacer click en el icono que lo selecciona.

![Chrome Dev Tools - Accessibility Tree](./assets/chrome-dev-tools.png)

Esto se puede hacer utilizando el m칠todo `page.accessibility.snapshot()`, que devuelve una representaci칩n del 치rbol de accesibilidad de la p치gina en formato JSON. Este 치rbol contiene informaci칩n sobre los roles, nombres accesibles y propiedades ARIA de los elementos en la p치gina.

Otra opci칩n es utilizar codegen para generar el 치rbol de accesibilidad de una p치gina web espec칤fica o de parte de ella. Para ello, podemos utilizar el siguiente comando:

```shell
npx playwright codegen <url>
```

En la ventana que muestra la pagina, podemos seleccionar el icono de Assert Snapshot (el 칰ltimo) y luego hacer click en un elemento de la p치gina para generar el 치rbol de accesibilidad correspondiente. El c칩digo generado incluir치 una llamada a `page.accessibility.snapshot()` para obtener el 치rbol de accesibilidad del elemento seleccionado y ser치 visible el la ventana de c칩digo de codegen.

Por ejemplo, en la web de ejemplo de Practice Software Testing, si seleccionamos el men칰 superior de la p치gina, el c칩digo generado ser치 similar al siguiente:

```ts
await expect(page.locator('app-header')).toMatchAriaSnapshot(`
    - link "Practice Software Testing - Toolshop":
      - /url: /
      - img
    - menubar "Main menu":
      - menuitem "Home":
        - link "Home":
          - /url: /
      - menuitem "Categories":
        - button "Categories"
      - menuitem "Contact":
        - link "Contact":
          - /url: /contact
      - menuitem "Sign in":
        - link "Sign in":
          - /url: /auth/login
    `);
```

Nuestro test con el matcher `toMatchAriaSnapshot()` validar치 que el 치rbol de accesibilidad del elemento `app-header` coincide con el snapshot esperado. Si el 치rbol de accesibilidad cambia, el test fallar치, lo que nos permitir치 detectar posibles problemas de accesibilidad en la aplicaci칩n web.

```ts
await expect(page.getByRole('menubar', { name: 'Main menu' })).toMatchAriaSnapshot(`
 - menuitem "Home":
        - link "Home":
          - /url: /
      - menuitem "Categories":
        - button "Categories"
      - menuitem "Contact":
        - link "Contact":
          - /url: /contact
      - menuitem "Sign in":
        - link "Sign in":
          - /url: /auth/login`);
```

Si solo queremos validar una parte del 치rbol de accesibilidad, podemos eliminar los elementos que no nos interesan del snapshot generado. El test solo fallara si los elementos incluidos en el snapshot no coinciden con el 치rbol de accesibilidad actual. No se trata por tanto de un "exact match", sino de un "partial match".

#### Tests de accesibilidad con axe-core

[Axe](https://www.deque.com/axe/) de Deque Labs es una de las bibliotecas m치s populares para realizar pruebas de accesibilidad automatizadas en aplicaciones web. Proporciona una serie de reglas y directrices basadas en los est치ndares de accesibilidad web, como WCAG (Web Content Accessibility Guidelines).

Para realizar tests de accesibilidad en Playwright disponemos del plugin [axe-core](https://playwright.dev/docs/accessibility-testing), y lo primero que haremos ser치 instalar la biblioteca `axe-playwright`:

```shell
npm i @axe-core/playwright -D
```

El plugin `axe-playwright` permite instanciar un objeto `AxeBuilder` que se utiliza para analizar la accesibilidad de la p치gina web y generar un informe de los problemas encontrados. A continuaci칩n se muestra un ejemplo b치sico de un test de accesibilidad utilizando Playwright y axe-core:

```typescript
import { test, expect } from '@playwright/test';
import { AxeBuilder } from '@axe-core/playwright';

test('Accessibility test with axe-core', async ({ page }) => {
  await page.goto('https://practicesoftwaretesting.com/');
  const report = await new AxeBuilder({ page }).analyze();
  expect(report.violations).toHaveLength(0);
});
```

Una de las configuraciones m치s comunes es filtrar las reglas que se van a analizar, seleccionando que est치ndares de accesibilidad se van a utilizar para el an치lisis, por ejemplo entre las versiones de WCAG:

```typescript
const report = await new AxeBuilder({ page })
  .withTags(['wcag2a', 'wcag2aa'])
  .analyze();
```
